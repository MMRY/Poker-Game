// Generated by CoffeeScript 1.6.3
(function() {
  var EventEmitter, Game, MachinePoker, Player, async, binions, botNameCollision,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  EventEmitter = require('events').EventEmitter;

  async = require('async');

  binions = require('binions');

  Player = binions.Player;

  Game = binions.Game;

  exports.seats = {
    JsLocal: require('./seats/js_local'),
    Remote: require('./seats/remote')
  };

  exports.betting = binions.betting;

  exports.observers = {
    fileLogger: require('./observers/file_logger'),
    logger: require('./observers/logger'),
    narrator: require('./observers/narrator')
  };

  exports.create = function(betting) {
    return new MachinePoker(betting);
  };

  MachinePoker = (function(_super) {
    __extends(MachinePoker, _super);

    function MachinePoker(opts) {
      this.opts = opts;
      if (this.opts == null) {
        this.opts = {};
      }
      this.chips = this.opts.chips || 1000;
      this.maxRounds = this.opts.maxRounds || 100;
      this.betting = this.opts.betting || binions.betting.noLimit(10, 20);
      this.observers = [];
      this.players = [];
      this.currentRound = 1;
    }

    MachinePoker.prototype.addObserver = function(obs) {
      var event, _i, _len, _ref, _results;
      this.observers.push(obs);
      _ref = ['roundStart', 'stateChange', 'complete', 'tournamentComplete', 'betAction'];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        event = _ref[_i];
        if (obs[event]) {
          _results.push(this.on(event, obs[event]));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    MachinePoker.prototype.addPlayers = function(bots) {
      var bot, name, names, _i, _len, _results;
      names = [];
      _results = [];
      for (_i = 0, _len = bots.length; _i < _len; _i++) {
        bot = bots[_i];
        name = botNameCollision(names, bot.name);
        names.push(name);
        _results.push(this.addPlayer(new Player(bot, this.chips, name)));
      }
      return _results;
    };

    MachinePoker.prototype.addPlayer = function(player) {
      var _this = this;
      player.on('betAction', function(action, amount, err) {
        return _this.emit('betAction', player, action, amount, err);
      });
      return this.players.push(player);
    };

    MachinePoker.prototype.run = function() {
      var game,
        _this = this;
      game = new Game(this.players, this.betting, this.currentRound);
      game.on('roundStart', function() {
        return _this.emit('roundStart', game.status(Game.STATUS.PRIVILEGED));
      });
      game.on('stateChange', function(state) {
        return _this.emit('stateChange', game.status(Game.STATUS.PRIVILEGED));
      });
      game.once('complete', function(status) {
        var numPlayer;
        _this.emit('complete', game.status(Game.STATUS.PRIVILEGED));
        _this.currentRound++;
        numPlayer = (_this.players.filter(function(p) {
          return p.chips > 0;
        })).length;
        if (_this.currentRound > _this.maxRounds || numPlayer < 2) {
          _this.emit('tournamentComplete', _this.players);
         return _this._close();
        } else {
          _this.players = _this.players.concat(_this.players.shift());
          return setImmediate(function() {
            return _this.run();
          });
        }
      });
      return game.run();
    };

    MachinePoker.prototype.start = function() {
      this.players.sort(function() {
        return Math.random() > 0.5;
      });
      return this.run();
    };

    MachinePoker.prototype._close = function(callback) {
      var obs, waitingOn, _i, _len, _ref;
      waitingOn = 0;
      _ref = this.observers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obs = _ref[_i];
        if (obs['onObserverComplete']) {
          waitingOn++;
          obs.onObserverComplete(function() {
            waitingOn--;
            if (waitingOn <= 0) {
              return typeof callback === "function" ? callback() : void 0;
            }
          });
        }
      }
      if (waitingOn <= 0) {
        // Ok, this is where the game exits. Let's call stuff out here

        // This is the opponent in the game that we played against
        console.log(this);
        console.log(this.players);

        var memBotWon = (this.players.filter(function(val, index, a) {
          return (val.name === "Memory Bot");})[0].chips > 1000);

        console.log(this.players);

        var enemyBot = this.players.filter(function(val, index, a) {
          return (val.name != "Memory Bot"); })[0].name;

        this.emit('tournamentClosed', enemyBot, memBotWon);
        return typeof callback === "function" ? callback() : void 0;
      }
    };

    return MachinePoker;

  })(EventEmitter);

  botNameCollision = function(existing, name, idx) {
    var altName;
    altName = name;
    idx || (idx = 1);
    if (idx > 1) {
      altName = "" + name + " #" + idx;
    }
    if (existing.indexOf(altName) >= 0) {
      return botNameCollision(existing, name, idx + 1);
    }
    return altName;
  };

}).call(this);
